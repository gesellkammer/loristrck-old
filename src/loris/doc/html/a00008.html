<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Loris: Loris::Channelizer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Loris
   &#160;<span id="projectnumber">1.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00008.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="a00104.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Loris::Channelizer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="a00068_source.html">Channelizer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae193d95c3fd451e4f501dbc072f6652b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#ae193d95c3fd451e4f501dbc072f6652b">Channelizer</a> (const <a class="el" href="a00022.html">Envelope</a> &amp;refChanFreq, int refChanLabel, double <a class="el" href="a00008.html#a02eee962c0a58aaddb78fdccc45f3691">stretchFactor</a>=0)</td></tr>
<tr class="separator:ae193d95c3fd451e4f501dbc072f6652b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42f8334b020a24a023206553696472a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#ae42f8334b020a24a023206553696472a">Channelizer</a> (double refFreq, double <a class="el" href="a00008.html#a02eee962c0a58aaddb78fdccc45f3691">stretchFactor</a>=0)</td></tr>
<tr class="separator:ae42f8334b020a24a023206553696472a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a5e553c5588b443f687fae7c8196ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#a37a5e553c5588b443f687fae7c8196ac">Channelizer</a> (const <a class="el" href="a00008.html">Channelizer</a> &amp;other)</td></tr>
<tr class="separator:a37a5e553c5588b443f687fae7c8196ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06df6442ecdf79bfb64cd29854f7d5cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00008.html">Channelizer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#a06df6442ecdf79bfb64cd29854f7d5cc">operator=</a> (const <a class="el" href="a00008.html">Channelizer</a> &amp;rhs)</td></tr>
<tr class="separator:a06df6442ecdf79bfb64cd29854f7d5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062739a7265189452588382716096671"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a062739a7265189452588382716096671"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#a062739a7265189452588382716096671">~Channelizer</a> (void)</td></tr>
<tr class="memdesc:a062739a7265189452588382716096671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy this <a class="el" href="a00008.html">Channelizer</a>. <br /></td></tr>
<tr class="separator:a062739a7265189452588382716096671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5eeeb3c992ec3306bd5380f8b8b4203"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#ac5eeeb3c992ec3306bd5380f8b8b4203">channelize</a> (<a class="el" href="a00049.html">Partial</a> &amp;partial) const </td></tr>
<tr class="separator:ac5eeeb3c992ec3306bd5380f8b8b4203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7948e8679e2def2197b08b93e55468"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:abe7948e8679e2def2197b08b93e55468"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00008.html#abe7948e8679e2def2197b08b93e55468">channelize</a> (Iter begin, Iter end) const </td></tr>
<tr class="separator:abe7948e8679e2def2197b08b93e55468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8fe66341da995c520e680328c4c4049"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa8fe66341da995c520e680328c4c4049"></a>
template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:aa8fe66341da995c520e680328c4c4049"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00008.html#aa8fe66341da995c520e680328c4c4049">operator()</a> (Iter begin, Iter end) const </td></tr>
<tr class="memdesc:aa8fe66341da995c520e680328c4c4049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function call operator: same as <a class="el" href="a00008.html#ac5eeeb3c992ec3306bd5380f8b8b4203">channelize()</a>. <br /></td></tr>
<tr class="separator:aa8fe66341da995c520e680328c4c4049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1e773885adbd1a29584e6230ec90a6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#a0d1e773885adbd1a29584e6230ec90a6">channelFrequencyAt</a> (double time, int channel) const </td></tr>
<tr class="separator:a0d1e773885adbd1a29584e6230ec90a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ec490bd36e3695d17ab133f6647dad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#ae9ec490bd36e3695d17ab133f6647dad">computeChannelNumber</a> (double time, double frequency) const </td></tr>
<tr class="separator:ae9ec490bd36e3695d17ab133f6647dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3c36d2fbb5ac983081efcc0c0fb193"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#aed3c36d2fbb5ac983081efcc0c0fb193">computeFractionalChannelNumber</a> (double time, double frequency) const </td></tr>
<tr class="separator:aed3c36d2fbb5ac983081efcc0c0fb193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806597f398f71193f6529984c01bdeb0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#a806597f398f71193f6529984c01bdeb0">referenceFrequencyAt</a> (double time) const </td></tr>
<tr class="separator:a806597f398f71193f6529984c01bdeb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b251d495844b418b53fff793847b9b3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#a0b251d495844b418b53fff793847b9b3">amplitudeWeighting</a> (void) const </td></tr>
<tr class="separator:a0b251d495844b418b53fff793847b9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3262873929a82abb61756a25a4aff04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#af3262873929a82abb61756a25a4aff04">setAmplitudeWeighting</a> (double expon)</td></tr>
<tr class="separator:af3262873929a82abb61756a25a4aff04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02eee962c0a58aaddb78fdccc45f3691"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#a02eee962c0a58aaddb78fdccc45f3691">stretchFactor</a> (void) const </td></tr>
<tr class="separator:a02eee962c0a58aaddb78fdccc45f3691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf50278506e5d14fe886bd449c34584"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#a2cf50278506e5d14fe886bd449c34584">setStretchFactor</a> (double stretch)</td></tr>
<tr class="separator:a2cf50278506e5d14fe886bd449c34584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89c9eff4d15c74d293cdcb718bc02ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#af89c9eff4d15c74d293cdcb718bc02ed">setStretchFactor</a> (double fm, int m, double fn, int n)</td></tr>
<tr class="separator:af89c9eff4d15c74d293cdcb718bc02ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a339e35098cb23174c37eb6f9fc0b06c7"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#a339e35098cb23174c37eb6f9fc0b06c7">computeStretchFactor</a> (double fm, int m, double fn, int n)</td></tr>
<tr class="separator:a339e35098cb23174c37eb6f9fc0b06c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4858e34d9bdd105dc7a75c66d4a6a473"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#a4858e34d9bdd105dc7a75c66d4a6a473">channelize</a> (<a class="el" href="a00052.html">PartialList</a> &amp;partials, const <a class="el" href="a00022.html">Envelope</a> &amp;refChanFreq, int refChanLabel)</td></tr>
<tr class="separator:a4858e34d9bdd105dc7a75c66d4a6a473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8d8fec152a60b33a2b4c5f221c595a"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:a9a8d8fec152a60b33a2b4c5f221c595a"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00008.html#a9a8d8fec152a60b33a2b4c5f221c595a">channelize</a> (Iter begin, Iter end, const <a class="el" href="a00022.html">Envelope</a> &amp;refChanFreq, int refChanLabel)</td></tr>
<tr class="separator:a9a8d8fec152a60b33a2b4c5f221c595a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08817ea7297dee34fbb6fe20be5dbb88"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#a08817ea7297dee34fbb6fe20be5dbb88">computeStretchFactor</a> (double f1, double fn, double n)</td></tr>
<tr class="separator:a08817ea7297dee34fbb6fe20be5dbb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class <a class="el" href="a00008.html">Channelizer</a> represents an algorithm for automatic labeling of a sequence of Partials. Partials must be labeled in preparation for morphing (see <a class="el" href="a00044.html">Morpher</a>) to establish correspondences between Partials in the morph source and target sounds.</p>
<p>Channelized partials are labeled according to their adherence to a harmonic frequency structure with a time-varying fundamental frequency. The frequency spectrum is partitioned into non-overlapping channels having time-varying center frequencies that are harmonic (integer) multiples of a specified reference frequency envelope, and each channel is identified by a unique label equal to its harmonic number. Each <a class="el" href="a00049.html">Partial</a> is assigned the label corresponding to the channel containing the greatest portion of its (the <a class="el" href="a00049.html">Partial</a>'s) energy.</p>
<p>A reference frequency <a class="el" href="a00022.html">Envelope</a> for channelization and the channel number to which it corresponds (1 for an <a class="el" href="a00022.html">Envelope</a> that tracks the <a class="el" href="a00049.html">Partial</a> at the fundamental frequency) must be specified. The reference <a class="el" href="a00022.html">Envelope</a> can be constructed explcitly, point by point (using, for example, the BreakpointEnvelope class), or constructed automatically using the <a class="el" href="a00025.html">FrequencyReference</a> class.</p>
<p>The <a class="el" href="a00008.html">Channelizer</a> can be configured with a stretch factor, to accomodate detuned harmonics, as in the case of piano tones. The static member computeStretchFactor can compute the apppropriate stretch factor, given a pair of partials. This computation is based on formulae given in "Understanding the complex nature of the piano tone" by Martin Keane at the Acoustics Research Centre at the University of Aukland (Feb 2004). The stretching factor must be non-negative (and is zero for perfectly tunes harmonics). Even in the case of stretched harmonics, the reference frequency envelope is assumed to track the frequency of one of the partials, and the center frequency of the corresponding channel, even though it may represent a stretched harmonic.</p>
<p><a class="el" href="a00008.html">Channelizer</a> is a leaf class, do not subclass. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae193d95c3fd451e4f501dbc072f6652b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Loris::Channelizer::Channelizer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00022.html">Envelope</a> &amp;&#160;</td>
          <td class="paramname"><em>refChanFreq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>refChanLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stretchFactor</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>exponent for amplitude weighting in channel computation, 0 for no weighting, 1 for linear amplitude weighting, 2 for power weighting, etc. default is 0, amplitude weighting is a bad idea for many sounds Construct a new <a class="el" href="a00008.html">Channelizer</a> using the specified reference <a class="el" href="a00022.html">Envelope</a> to represent the a numbered channel. If the sound being channelized is known to have detuned harmonics, a stretching factor can be specified (defaults to 0 for no stretching). The stretching factor can be computed using the static member computeStretchFactor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refChanFreq</td><td>is an <a class="el" href="a00022.html">Envelope</a> representing the center frequency of a channel. </td></tr>
    <tr><td class="paramname">refChanLabel</td><td>is the corresponding channel number (i.e. 1 if refChanFreq is the lowest-frequency channel, and all other channels are harmonics of refChanFreq, or 2 if refChanFreq tracks the second harmonic, etc.). </td></tr>
    <tr><td class="paramname">stretchFactor</td><td>is a stretching factor to account for detuned harmonics, default is 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidArgument</td><td>if refChanLabel is not positive. </td></tr>
    <tr><td class="paramname">InvalidArgument</td><td>if stretchFactor is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae42f8334b020a24a023206553696472a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Loris::Channelizer::Channelizer </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>refFreq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stretchFactor</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a new <a class="el" href="a00008.html">Channelizer</a> having a constant reference frequency. The specified frequency is the center frequency of the lowest-frequency channel (for a harmonic sound, the channel containing the fundamental <a class="el" href="a00049.html">Partial</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refFreq</td><td>is the reference frequency (in Hz) corresponding to the first frequency channel. </td></tr>
    <tr><td class="paramname">stretchFactor</td><td>is a stretching factor to account for detuned harmonics, default is 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidArgument</td><td>if refChanLabel is not positive. </td></tr>
    <tr><td class="paramname">InvalidArgument</td><td>if stretchFactor is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a37a5e553c5588b443f687fae7c8196ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Loris::Channelizer::Channelizer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00008.html">Channelizer</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a new <a class="el" href="a00008.html">Channelizer</a> that is an exact copy of another. The copy represents the same set of frequency channels, constructed from the same reference <a class="el" href="a00022.html">Envelope</a> and channel number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>is the <a class="el" href="a00008.html">Channelizer</a> to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0b251d495844b418b53fff793847b9b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Loris::Channelizer::amplitudeWeighting </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the exponent applied to amplitude before weighting the instantaneous estimate of the frequency channel number for a <a class="el" href="a00049.html">Partial</a>. zero (default) for no weighting, 1 for linear amplitude weighting, 2 for power weighting, etc. Amplitude weighting is a bad idea for many sounds, particularly those with transients, for which it may emphasize the part of the <a class="el" href="a00049.html">Partial</a> having the least reliable frequency estimate. </p>

</div>
</div>
<a class="anchor" id="a0d1e773885adbd1a29584e6230ec90a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Loris::Channelizer::channelFrequencyAt </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the center frequency of one a channel at the specified time. For non-stretched harmonics, this is simply the value of the reference envelope scaled by the ratio of the specified channel number to the reference channel number. For stretched harmonics, the channel center frequency is computed using the stretch factor. See Martin Keane, "Understanding
the complex nature of the piano tone", 2004, for a discussion and the source of the mode frequency stretching algorithms implemented here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>is the time (in seconds) at which to evalute the reference envelope </td></tr>
    <tr><td class="paramname">channel</td><td>is the frequency channel (or harmonic, or vibrational mode) number whose frequency is to be determined </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the center frequency in Hz of the specified frequency channel at the specified time </dd></dl>

</div>
</div>
<a class="anchor" id="ac5eeeb3c992ec3306bd5380f8b8b4203"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Loris::Channelizer::channelize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00049.html">Partial</a> &amp;&#160;</td>
          <td class="paramname"><em>partial</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Label a <a class="el" href="a00049.html">Partial</a> with the number of the frequency channel containing the greatest portion of its (the <a class="el" href="a00049.html">Partial</a>'s) energy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partial</td><td>is the <a class="el" href="a00049.html">Partial</a> to label. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abe7948e8679e2def2197b08b93e55468"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Loris::Channelizer::channelize </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assign each <a class="el" href="a00049.html">Partial</a> in the specified half-open (STL-style) range the label corresponding to the frequency channel containing the greatest portion of its (the <a class="el" href="a00049.html">Partial</a>'s) energy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>is the beginning of the range of Partials to channelize </td></tr>
    <tr><td class="paramname">end</td><td>is (one-past) the end of the range of Partials to channelize</td></tr>
  </table>
  </dd>
</dl>
<p>If compiled with NO_TEMPLATE_MEMBERS defined, then begin and end must be PartialList::iterators, otherwise they can be any type of iterators over a sequence of Partials.</p>
<p>Assign each <a class="el" href="a00049.html">Partial</a> in the specified half-open (STL-style) range the label corresponding to the frequency channel containing the greatest portion of its (the <a class="el" href="a00049.html">Partial</a>'s) energy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>is the beginning of the range of Partials to channelize </td></tr>
    <tr><td class="paramname">end</td><td>is (one-past) the end of the range of Partials o channelize</td></tr>
  </table>
  </dd>
</dl>
<p>If compiled with NO_TEMPLATE_MEMBERS defined, then begin and end must be PartialList::iterators, otherwise they can be any type of iterators over a sequence of Partials. </p>

</div>
</div>
<a class="anchor" id="a4858e34d9bdd105dc7a75c66d4a6a473"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Loris::Channelizer::channelize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00052.html">PartialList</a> &amp;&#160;</td>
          <td class="paramname"><em>partials</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00022.html">Envelope</a> &amp;&#160;</td>
          <td class="paramname"><em>refChanFreq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>refChanLabel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Static member that constructs an instance and applies it to a <a class="el" href="a00052.html">PartialList</a> (simplified interface).</p>
<p>Construct a <a class="el" href="a00008.html">Channelizer</a> using the specified <a class="el" href="a00022.html">Envelope</a> and reference label, and use it to channelize a sequence of Partials.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partials</td><td>is the sequence of Partials to channelize. </td></tr>
    <tr><td class="paramname">refChanFreq</td><td>is an <a class="el" href="a00022.html">Envelope</a> representing the center frequency of a channel. </td></tr>
    <tr><td class="paramname">refChanLabel</td><td>is the corresponding channel number (i.e. 1 if refChanFreq is the lowest-frequency channel, and all other channels are harmonics of refChanFreq, or 2 if refChanFreq tracks the second harmonic, etc.). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidArgument</td><td>if refChanLabel is not positive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a8d8fec152a60b33a2b4c5f221c595a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Loris::Channelizer::channelize </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00022.html">Envelope</a> &amp;&#160;</td>
          <td class="paramname"><em>refChanFreq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>refChanLabel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>DEPRECATED</p>
<p>Static member that constructs an instance and applies it to a sequence of Partials. Construct a <a class="el" href="a00008.html">Channelizer</a> using the specified <a class="el" href="a00022.html">Envelope</a> and reference label, and use it to channelize a sequence of Partials.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>is the beginning of a sequence of Partials to channelize. </td></tr>
    <tr><td class="paramname">end</td><td>is the end of a sequence of Partials to channelize. </td></tr>
    <tr><td class="paramname">refChanFreq</td><td>is an <a class="el" href="a00022.html">Envelope</a> representing the center frequency of a channel. </td></tr>
    <tr><td class="paramname">refChanLabel</td><td>is the corresponding channel number (i.e. 1 if refChanFreq is the lowest-frequency channel, and all other channels are harmonics of refChanFreq, or 2 if refChanFreq tracks the second harmonic, etc.). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidArgument</td><td>if refChanLabel is not positive.</td></tr>
  </table>
  </dd>
</dl>
<p>If compiled with NO_TEMPLATE_MEMBERS defined, then begin and end must be PartialList::iterators, otherwise they can be any type of iterators over a sequence of Partials. </p>

</div>
</div>
<a class="anchor" id="ae9ec490bd36e3695d17ab133f6647dad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Loris::Channelizer::computeChannelNumber </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>frequency</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the (fractional) channel number estimate for a <a class="el" href="a00049.html">Partial</a> having a given frequency at a specified time. For ordinary harmonics, this is simply the ratio of the specified frequency to the reference frequency at the specified time. For stretched harmonics (as in a piano), the stretching factor is used to compute the frequency of the corresponding modes of a massy string. See Martin Keane, "Understanding the complex nature of the piano tone", 2004, for the source of the mode frequency stretching algorithms implemented here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>is the time (in seconds) at which to evalute the reference envelope </td></tr>
    <tr><td class="paramname">frequency</td><td>is the frequency (in Hz) for wihch the channel number is to be determined </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the channel number corresponding to the specified frequency and time </dd></dl>

</div>
</div>
<a class="anchor" id="aed3c36d2fbb5ac983081efcc0c0fb193"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Loris::Channelizer::computeFractionalChannelNumber </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>frequency</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the (fractional) channel number estimate for a <a class="el" href="a00049.html">Partial</a> having a given frequency at a specified time. For ordinary harmonics, this is simply the ratio of the specified frequency to the reference frequency at the specified time. For stretched harmonics (as in a piano), the stretching factor is used to compute the frequency of the corresponding modes of a massy string. See Martin Keane, "Understanding the complex nature of the piano tone", 2004, for the source of the mode frequency stretching algorithms implemented here.</p>
<p>The fractional channel number is used internally to determine a best estimate for the channel number (label) for a <a class="el" href="a00049.html">Partial</a> having time-varying frequency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>is the time (in seconds) at which to evalute the reference envelope </td></tr>
    <tr><td class="paramname">frequency</td><td>is the frequency (in Hz) for wihch the channel number is to be determined </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the fractional channel number corresponding to the specified frequency and time </dd></dl>

</div>
</div>
<a class="anchor" id="a339e35098cb23174c37eb6f9fc0b06c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double Loris::Channelizer::computeStretchFactor </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Static member to compute the stretch factor for a sound having (consistently) detuned harmonics, like piano tones.</p>
<p>The stretching factor is a small positive number for heavy vibrating strings (as in pianos) for which the mass of the string significantly affects the frequency of the vibrating modes. See Martin Keane, "Understanding
the complex nature of the piano tone", 2004, for a discussion and the source of the mode frequency stretching algorithms implemented here.</p>
<p>The value returned by this function MAY NOT be a valid stretch factor. If this function returns a negative stretch factor, then the specified pair of frequencies and mode numbers cannot be used to estimate the effects of string mass on mode frequency (because the negative stretch factor implies a physical impossibility, like negative mass or negative length).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fm</td><td>is the frequency of the Mth stretched harmonic </td></tr>
    <tr><td class="paramname">m</td><td>is the harmonic number of the harmonic whose frequnecy is fm </td></tr>
    <tr><td class="paramname">fn</td><td>is the frequency of the Nth stretched harmonic </td></tr>
    <tr><td class="paramname">n</td><td>is the harmonic number of the harmonic whose frequnecy is fn </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the stretching factor, usually a very small positive floating point number, or 0 for pefectly tuned harmonics (that is, if fn = n*f1). </dd></dl>

</div>
</div>
<a class="anchor" id="a08817ea7297dee34fbb6fe20be5dbb88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double Loris::Channelizer::computeStretchFactor </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>DEPRECATED</p>
<p>Static member to compute the stretch factor for a sound having (consistently) detuned harmonics, like piano tones. Legacy version that assumes the first argument corresponds to the first partial.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f1</td><td>is the frequency of the lowest numbered (1) partial. </td></tr>
    <tr><td class="paramname">fn</td><td>is the frequency of the Nth stretched harmonic </td></tr>
    <tr><td class="paramname">n</td><td>is the harmonic number of the harmonic whose frequnecy is fn </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the stretching factor, usually a very small positive floating point number, or 0 for pefectly tuned harmonics (that is, for harmonic frequencies fn = n*f1). </dd></dl>

</div>
</div>
<a class="anchor" id="a06df6442ecdf79bfb64cd29854f7d5cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00008.html">Channelizer</a>&amp; Loris::Channelizer::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00008.html">Channelizer</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment operator: make this <a class="el" href="a00008.html">Channelizer</a> an exact copy of another. This <a class="el" href="a00008.html">Channelizer</a> is made to represent the same set of frequency channels, constructed from the same reference <a class="el" href="a00022.html">Envelope</a> and channel number as rhs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>is the <a class="el" href="a00008.html">Channelizer</a> to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a806597f398f71193f6529984c01bdeb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Loris::Channelizer::referenceFrequencyAt </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the reference frequency at the specified time. For non-stretched harmonics, this is simply the ratio of the reference envelope evaluated at that time to the reference channel number, and is the center frequecy for the lowest channel. For stretched harmonics, the reference frequency is NOT equal to the center frequency of any of the channels, and is also a function of the stretch factor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>is the time (in seconds) at which to evalute the reference envelope </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af3262873929a82abb61756a25a4aff04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Loris::Channelizer::setAmplitudeWeighting </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>expon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the exponent applied to amplitude before weighting the instantaneous estimate of the frequency channel number for a <a class="el" href="a00049.html">Partial</a>. zero (default) for no weighting, 1 for linear amplitude weighting, 2 for power weighting, etc. Amplitude weighting is a bad idea for many sounds, particularly those with transients, for which it may emphasize the part of the <a class="el" href="a00049.html">Partial</a> having the least reliable frequency estimate. </p>

</div>
</div>
<a class="anchor" id="a2cf50278506e5d14fe886bd449c34584"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Loris::Channelizer::setStretchFactor </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stretch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the stretching factor used to account for detuned harmonics, as in a piano tone. Normally set to 0 for in-tune harmonics. The stretching factor for massy vibrating strings (like pianos) can be computed from the physical characteristics of the string, or using <a class="el" href="a00008.html#a339e35098cb23174c37eb6f9fc0b06c7">computeStretchFactor()</a>.</p>
<p>The stretching factor is a small positive number for heavy vibrating strings (as in pianos) for which the mass of the string significantly affects the frequency of the vibrating modes. See Martin Keane, "Understanding
the complex nature of the piano tone", 2004, for a discussion and the source of the mode frequency stretching algorithms implemented here.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidArgument</td><td>if stretch is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af89c9eff4d15c74d293cdcb718bc02ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Loris::Channelizer::setStretchFactor </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DEPRECATED</p>
<p>Set the stretching factor used to account for (consistently) detuned harmonics, as in a piano tone, from a pair of mode (harmonic) frequencies and numbers.</p>
<p>The stretching factor is a small positive number for heavy vibrating strings (as in pianos) for which the mass of the string significantly affects the frequency of the vibrating modes. See Martin Keane, "Understanding
the complex nature of the piano tone", 2004, for a discussion and the source of the mode frequency stretching algorithms implemented here.</p>
<p>The stretching factor is computed using computeStretchFactor, but only a valid stretch factor will ever be assigned. If an invalid (negative) stretching factor is computed for the specified frequencies and mode numbers, the stretch factor will be set to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fm</td><td>is the frequency of the Mth stretched harmonic </td></tr>
    <tr><td class="paramname">m</td><td>is the harmonic number of the harmonic whose frequnecy is fm </td></tr>
    <tr><td class="paramname">fn</td><td>is the frequency of the Nth stretched harmonic </td></tr>
    <tr><td class="paramname">n</td><td>is the harmonic number of the harmonic whose frequnecy is fn </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a02eee962c0a58aaddb78fdccc45f3691"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Loris::Channelizer::stretchFactor </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the stretching factor used to account for detuned harmonics, as in a piano tone. Normally set to 0 for in-tune harmonics.</p>
<p>The stretching factor is a small positive number for heavy vibrating strings (as in pianos) for which the mass of the string significantly affects the frequency of the vibrating modes. See Martin Keane, "Understanding
the complex nature of the piano tone", 2004, for a discussion and the source of the mode frequency stretching algorithms implemented here. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a00068_source.html">Channelizer.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>Loris</b></li><li class="navelem"><a class="el" href="a00008.html">Channelizer</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
